1)

A.
    function OutVec = convertTempWhile(InVec, str)
    counter = 1;
    temp_val = size(InVec);
    if strcmp(str,'F2C')
        OutVec = zeros(size(InVec));
        while temp_val(2) >= counter
            OutVec(counter) = (InVec(counter) - 32)*(5/9);
            counter = counter + 1;
        end
    elseif strcmp(str,'C2F')
        OutVec = zeros(size(InVec));
        while temp_val(2) >= counter
            OutVec(counter) = (InVec(counter)*(9/5)+32);
            counter = counter + 1;
        end
    else
        disp('Error!')
    end
end

>> convertTempWhile(InVec,'C2F')

ans =

  Columns 1 through 7

    -4     5    14    23    32    41    50

  Columns 8 through 13

    59    68    77    86    95   104

>> convertTempWhile(InVec,'F2C')

ans =

  Columns 1 through 4

  -28.8889  -26.1111  -23.3333  -20.5556

  Columns 5 through 8

  -17.7778  -15.0000  -12.2222   -9.4444

  Columns 9 through 12

   -6.6667   -3.8889   -1.1111    1.6667

  Column 13

    4.4444

B.






3)

    List = { {'M','A','T','L','A','B'},{' '},{'i','s'}, {' '}, {'a'}, {' '}, {'s','t','r','a','n','g','e'},{', '}, {'b','u','t',' '}, {'p','o','p','u','l','a','r'}, {' '}, {'p','r','o','g','r','a','m','m','i','n','g',' ','l','a','n','g','u','a','g','e'}}; 
for numbers = 1:length(List)
    a = List{numbers};
    for numbers_one = 1:1:length(a)
        fprintf(a{numbers_one});
    end    
end

>> extractLetter
MATLAB is a strange, but popular programming language

4)

    This function runs a for loop, n, which square roots an r value 2.0 and squares the following value for a max of 60 iterations on each respective math operation.
    When you run the code, it outputs a final value of 1 because of the round-off erros in numerical computaiton. In Matlab, the value r becomes exponentially smaller, 
    and then rounds, which in turn the estimated value is squared to a value of 1.
    
5)

    This code runs an initial value eps = 1.0 through a while loop, which when eps + 1.0 is not equal to 1.0, it displays the eps value and then divides the eps value by 2.
    This continues until the eps value becomes infinitessimaly small, in which matlab will round this value to 0, and at this instance, eps will equal to 0. This is make the
    while look break because the statement will be true (1.0 = 1.0 + eps).

6)

    function getLargestPrime(x)
    for i = x:-1:2
        y = isprime(i);
        if y == 1
            disp(i)
            return
        else
            continue
        end
    end
    
    >> getLargestPrime(123)
   113
   
7)

A.

    function fib()

    n = input('Please enter a non-negative integer or type stop: ','s');
    if strcmp(n,'stop')
        return
    else
        n = str2double(n);
        if isreal(n)
            if n>=0 && round(n)==n
                disp(['fib(',num2str(n),') = ',num2str(getFib(n))]);
                
                f = @() getFib(n);
                disp([ char(9) 'average runtime: ' num2str(timeit(f))]);
                
                fib()
                return
            end
        end
        disp('The input argument is not a non-negative integer!');
        fib()
    end
    
    function fib = getFib(n_int)
        if n_int == 0
            fib = 0;
        elseif n_int == 1
            fib = 1;
        else
            fib = getFib(n_int-1) + getFib(n_int-2);
        end
    end

end

    fib(10) = 55

f =

  function_handle with value:

    @()getFib(n)

	average runtime: 2.7628e-05
    
B.


    
